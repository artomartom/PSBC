
for(int i {};auto x : std::as_const(str)) {  } //initializers in range based for 
for(auto object : {object1, object2, object3}) {   // work } //&& initializer list 


/**
*    Delegating constructors   
*/
struct  someclassctr
{
    someclassctr(int i ):member{i}{};
    someclassctr(const char * )
    :someclassctr(5){};
    int member;
};

/**
 *  HLSL Shader register binding syntax
 *  t – for shader resource views (SRV)
 *  s – for samplers
 *  u – for unordered access views (UAV)
 *  b – for constant buffer views (CBV)
 */

/**   this fokin wierd function from "the book of shaders"
 *   float plot(float st, float pct){
 * return  smoothstep( pct-0.02, pct, st) -
 *         smoothstep( pct, pct+0.02, st);
 *}
 */

 /** rename  git branch
 * git branch -m master main
 */
 /** remove git submodule
 *  git rm <path-to-submodule>
 */

/** push localName branch  to remoteName remote branch
 * git push -u origin localName:remoteName
 */
 
 
/**
make git track submodule at a branch 
cd /path/to/your/parent/repo
  git config -f .gitmodules submodule.<path>.branch <branch>

cd path/to/your/submodule
  git checkout -b branch --track origin/branch
    # if the master branch already exist:
    git branch -u origin/master master
    
cd /path/to/your/parent/repo
  git add path/to/your/submodule
  git commit -m "Make submodule tracking a branch"
  #Subsequent update for that submodule will have to use the --remote option: 
  # update your submodule
  # --remote will also fetch and ensure that
  # the latest commit from the branch is used
  git submodule update --remote

  # to avoid fetching use
  git submodule update --remote --no-fetch 






*/

__________________________________________

 { wchar_t buf [25];
            swprintf(buf, 25, L" %.2f:%.2f", (((float)GET_X_LPARAM(lParam)-float(pProgram->GetClientRectWidth() )/2.0f)/(pProgram->GetClientRectWidth()/2.0f)),
                                         -(((float)GET_Y_LPARAM(lParam)-float(pProgram->GetClientRectHeight())/2.0f)/(pProgram->GetClientRectHeight()/2.0f))
                    );
        SetWindowTextW(hWnd,buf);
        }

windows Screen coordinate system to openGl system
__________________________________________

 operator TypeName {return member} cast object to its member type   (TypeName)Object = member 

__________________________________________
__________________________________________
class g 
 {
     public:
     const char * operator()(char) const { return "char"; };
     const char * operator()(int ) const { return "int "; };
     
 };
g G 
G(int())
G(12)
g{}('c')
__________________________________________
__________________________________________
 derived constructor can only call a directly inherited class's constructor 
__________________________________________
Raw String  Literal  R"" 
"<a href=\"file\">C:\\Program Files\\</a>"
R"(<a href="file">C:\Program Files\</a>)"
			 R"( multiline 
                              raw 
                              string 
                              literals )";
__________________________________________
__________________________________________
__________________________________________
__________________________________________
A constant member function cannot modify any non-static data members or call any member functions that aren't constant.
__________________________________________
__________________________________________
The following kinds of identifiers have no linkage:
-Names that have neither external nor internal linkage
-Names declared in local scopes (with exceptions of certain entities declared with the extern keyword)
-Identifiers that do not represent an object or a function, including labels, enumerators, 
typedef names that refer to entities with no linkage, type names, function parameters, and  stemplate names 
__________________________________________
__________________________________________
__________________________________________
for pointer to base class pointing to derived 
to call a function overridden by derived 
this function has to be virtual in base 
/
for pointer to base class pointing to derived 
to call both base's and derived's destructors -
base destructor  has to be virtual  

__________________________________________

__________________________________________
Since nobody else has mentioned it:
The use of .inl files to store your inline functions can be useful for speeding up compiles.
If you only include the declarations (.h) where you need declarations, and only include inline implementations (.inl) where you need them ( i.e. probably only in .cpp and other .inl files, not .h's ), it can have a beneficial effect on your header dependencies.
This can be a significant win on larger projects with many interacting classes.
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
