float InverseLerp (float a,float b,float v   )
{
return (v-a)/(b-a);
}
__________________________________________

 { wchar_t buf [25];
            swprintf(buf, 25, L" %.2f:%.2f", (((float)GET_X_LPARAM(lParam)-float(pProgram->GetClientRectWidth() )/2.0f)/(pProgram->GetClientRectWidth()/2.0f)),
                                         -(((float)GET_Y_LPARAM(lParam)-float(pProgram->GetClientRectHeight())/2.0f)/(pProgram->GetClientRectHeight()/2.0f))
                    );
        SetWindowTextW(hWnd,buf);
        }

windows Screen coordinate system to openGl system
__________________________________________

 operator TypeName {return member} cast object to its member type   (TypeName)Object = member 

__________________________________________
__________________________________________
class g 
 {
     public:
     const char * operator()(char) const { return "char"; };
     const char * operator()(int ) const { return "int "; };
     
 };
g G 
G(int())
G(12)
g{}('c')
__________________________________________
__________________________________________
 derived constructor can only call a directly inherited class's constructor 
__________________________________________
Raw String  Literal  R"" 
"<a href=\"file\">C:\\Program Files\\</a>"
R"(<a href="file">C:\Program Files\</a>)"
			 R"( multiline 
                              raw 
                              string 
                              literals )";
__________________________________________
__________________________________________
__________________________________________
__________________________________________
A constant member function cannot modify any non-static data members or call any member functions that aren't constant.
__________________________________________
__________________________________________
The following kinds of identifiers have no linkage:
-Names that have neither external nor internal linkage
-Names declared in local scopes (with exceptions of certain entities declared with the extern keyword)
-Identifiers that do not represent an object or a function, including labels, enumerators, 
typedef names that refer to entities with no linkage, type names, function parameters, and  stemplate names 
__________________________________________
shift +right click   open context menu with "copy as path  " additional command 
__________________________________________
gflags /i hello_DLL.exe  +sls
__________________________________________
for pointer to base class pointing to derived 
to call a function overridden by derived 
this function has to be virtual in base 
/
for pointer to base class pointing to derived 
to call both base's and derived's destructors -
base destructor  has to be virtual  

__________________________________________
destructor is always  noexcept 
__________________________________________
Since nobody else has mentioned it:
The use of .inl files to store your inline functions can be useful for speeding up compiles.
If you only include the declarations (.h) where you need declarations, and only include inline implementations (.inl) where you need them ( i.e. probably only in .cpp and other .inl files, not .h's ), it can have a beneficial effect on your header dependencies.
This can be a significant win on larger projects with many interacting classes.
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
__________________________________________
